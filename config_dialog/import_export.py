'''
Created on Jan 29, 2020

@author: dstokes
'''
from __future__ import absolute_import, print_function

from fnmatch import filter as fnfilter
import os.path

import wx

from mide_ebml.ebmlite import loadSchema, Element
from .base import logger, ConfigBase
from . import legacy

#===============================================================================
# 
#===============================================================================

def makeExpression(exp, configId=None, label=None):
    """ Helper method for compiling an expression in a string into a code
        object that can later be used with `eval()`.
    """
    name = "displayFormat"
    if exp is None:
        # No expression defined: value is returned unmodified (it matches 
        # the config item's type)
        return None#ConfigBase.noEffect
    elif exp is '':
        # Empty string expression: always returns `None` (e.g. the field is
        # used to calculate another config item, not a config item itself)
        return ConfigBase.noValue
    elif not isinstance(exp, basestring):
        # Probably won't occur, but just in case...
        logger.debug("Bad value for %s: %r (%s)" % (name, exp, exp.__class__))
        return
    
    # Create a nicely formatted, informative string for the compiled 
    # expression's "filename" and for display if the expression is bad.
    idstr = ("(ID 0x%0X) " % configId) if configId else ""
    msg = "%r %s%s" % (label, idstr, name)
    
    try:
        return compile(exp, "<%s>" % msg, "eval")
    except SyntaxError as err:
        logger.error("Ignoring bad expression (%s) for %s: %r" % 
                     (err.msg, msg, err.text))
        return ConfigBase.noValue


def makeGainOffsetFormat(gain=1.0, offset=0.0, configId=None, label=None):
    """ Helper method for generating `displayFormat` expressions using a
        field's `gain` and `offset`.
    """
    gain = 1.0 if gain is None else gain
    offset = 0.0 if offset is None else offset
    # Create a nicely formatted, informative string for the compiled 
    # expression's "filename" and for display if the expression is bad.
    idstr = (" (ID 0x%0X)" % configId) if configId else ""
    msg = "%r%s" % (label, idstr)
    
    displayFormat = compile("(x+%.8f)*%.8f" % (offset, gain), 
                                 "%s displayFormat" % msg, "eval")
    
    return displayFormat


#===============================================================================
# 
#===============================================================================

def getConverters(configUi, data=None):
    """ Recursively get "DisplayFormat" expressions from dumped CONFIG.UI
        data. Fields without a conversion expression or display gain/offset
        are ignored.
    
        @param configUi: A dictionary generated by calling the `dump()` method
            on a CONFIG.UI EBML element.
        @return: A dictionary of compiled `eval` code objects, keyed by
            the field's `ConfigID`.
    """
    if data is None:
        data = {}
    
    if isinstance(configUi, Element):
        configUi = configUi.dump()
        
    if isinstance(configUi, list):
        for el in configUi:
            getConverters(el, data)
        return data
    elif not isinstance(configUi, dict):
        return data
    
    configId = configUi.get('ConfigID', None)
    if configId is not None:
        label = configUi.get('Label', None)
        displayFormat = configUi.get('DisplayFormat', None)
        gain = fnfilter(configUi, '*Gain')
        offset = fnfilter(configUi, '*Offset')
        
        gain = configUi[gain[0]] if gain else None
        offset = configUi[offset[0]] if offset else None
            
        if gain or offset:
            data[configId] = makeGainOffsetFormat(gain, offset, configId, label)
        elif displayFormat:
            data[configId] = makeExpression(displayFormat, configId, label)
    
    for v in configUi.values():
        if isinstance(v, (list, dict)):
            getConverters(v, data)
    
    return data
    
#===============================================================================
# 
#===============================================================================

def checkCompatibility(dev, configUi, devprops):
    """
    """
    


#===============================================================================
# 
#===============================================================================

def importConfig(dlg):
    """
    """
    types = "Exported configuration data (*.cfx)|*.cfx|" \
            "Device configuration file (*.cfg)|*.cfg"

    done = False

    dlg = wx.FileDialog(dlg, message="Import Configuration Data",
                        wildcard=types, style=wx.FD_OPEN)

    while not done:
        filename = None
        if dlg.ShowModal() == wx.ID_OK:
            filename = dlg.GetPath()
            # XXX: Do some checks on the data


def loadExport(filename):
    """ Load data from an exported configuration file.
    
        @param filename: The name of the exported file.
        @return: A dictionary containing EBML elements with the keys:
            * ``'ConfigUI'``
            * ``'RecorderConfigurationList'``
            * ``'RecordingProperties'``
    """
    mideSchema = loadSchema('mide.xml')
    uiSchema = loadSchema('config_ui.xml')

    doc = mideSchema.load(filename)
    result = {el.name: el for el in doc[0]}
    
    config = result.get('RecorderConfigurationList', None)
    configUi = result.get('ConfigUI', None)
    props = result.get('RecordingProperties', None)
    
    if configUi is not None:
        configUi = uiSchema.loads(configUi)
    
    return (config, configUi, props)
    

#===============================================================================
# 
#===============================================================================

def exportConfig(device, filename, config=None, configUi=None, props=None):
    """ Generate a configuration export file. 
    
        @param filename: The name of the file to write.
        @keyword config: Configuration data to write, as nested dictionaries
            as generated by calling `dump()` on a `RecorderConfigurationList`
            element. If `None`, the data will be read from the device.
        @keyword configUi: The device's configuration UI, as an
            `ebmlite.Document`. If `None`, the data will be read from the
            device.
        @keyword props: The device's properties, as nested dictionaries
            as generated by calling `dump()` on a `RecordingProperties`
            element or calling the device's `Recorder.getProperties()`. If
            `None`, the data will be read from the device.
    """
    mideSchema = loadSchema('mide.xml')

    # Get and/or prepare CONFIG.UI data
    if configUi is None:
        uiFile = getattr(device, 'configUIFile', None)
        if uiFile is None or not os.path.exists(uiFile):
            # Load default ConfigUI for the device from static XML.
            configUi = legacy.loadConfigUI(device)
        else:
            logger.debug('Loading ConfigUI from %s' % uiFile)
            configUi = mideSchema.load(uiFile)

    # Get and/or prepare configuration data
    if config is None:
        # No data provided. Read from device.
        logger.debug('Loading config data from %s' % device.configFile)
        config = mideSchema.load(device.configFile).dump()
    else:
        logger.debug('Using provided config data')
        
    if ('RecorderConfigurationList' not in config and \
        'RecorderConfigurationItem' not in config):
        # Legacy format data. Attempt to convert.
        logger.debug('Converting legacy config data')
        config = legacy.loadConfigData(device)

    if 'RecorderConfigurationList' in config:
        # Get contents; the outer element is added on encoding.
        config = config['RecorderConfigurationList']

    # Get and/or prepare `RecordingProperties` data
    if props is None:
        props = device.getProperties()
    if 'RecordingProperties' in props:
        # Get contents; the outer element is added on encoding.
        props = props['RecordingProperties']

    # Encode and write
    data =  {'RecorderConfigurationList': config,
             'RecordingProperties': props,
             'ConfigUI': configUi.getRaw()}
    
    with open(filename, 'wb') as f:
        mideSchema.encode(f, {'ExportedConfigurationData': data})
    
    return data
