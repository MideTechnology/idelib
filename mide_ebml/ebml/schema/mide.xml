<?xml version="1.0" encoding="utf-8"?>

<!-- The list of element parameters for this file seems to be: 
	name="MyElement"
	(cppname)="ParentMyElement (arbitrary)"
	level="0"
	id="0x1234"
	type="master, uinteger, integer, binary, string, utf=8, float"
	mandatory="0"
	multiple="0"
	minver="1"
	range="> 0, not 0, 1-30" ... seems to be arbitrary / probably not checked. 
	bytesize="16"
	default="123" or a text value that may or may not be the name of another tag
	
	(webm)
	(divx)
-->

<table>
  <!-- Base EBML elements. Required. -->
  <element name="EBML" level="0" id="0x1A45DFA3" type="master" mandatory="1" multiple="1" minver="1">Set the EBML characteristics of the data to follow. Each EBML document has to start with this.</element>
  <element name="EBMLVersion" level="1" id="0x4286" type="uinteger" mandatory="1" default="1" minver="1">The version of EBML parser used to create the file.</element>
  <element name="EBMLReadVersion" level="1" id="0x42F7" type="uinteger" mandatory="1" default="1" minver="1">The minimum EBML version a parser has to support to read this file.</element>
  <element name="EBMLMaxIDLength" level="1" id="0x42F2" type="uinteger" mandatory="1" default="4" minver="1">The maximum length of the IDs you'll find in this file (4 or less in Matroska).</element>
  <element name="EBMLMaxSizeLength" level="1" id="0x42F3" type="uinteger" mandatory="1" default="8" minver="1">The maximum length of the sizes you'll find in this file (8 or less in Matroska). This does not override the element size indicated at the beginning of an element. Elements that have an indicated size which is larger than what is allowed by EBMLMaxSizeLength shall be considered invalid.</element>
  <element name="DocType" level="1" id="0x4282" type="string" mandatory="1" default="mide" minver="1">A string that describes the type of document that follows this EBML header. 'mide' for Mide Instrumentation Data Exchange files.</element>
  <element name="DocTypeVersion" level="1" id="0x4287" type="uinteger" mandatory="1" default="2" minver="1">The version of DocType interpreter used to create the file.</element>
  <element name="DocTypeReadVersion" level="1" id="0x4285" type="uinteger" mandatory="1" default="2" minver="1">The minimum DocType version an interpreter has to support to read this file.</element>
  <element name="Void" level="-1" id="0xEC" type="binary" minver="1">Used to void damaged data, to avoid unexpected behaviors when using damaged data. The content is discarded. Also used to reserve space in a sub-element for later use.</element>
  <element name="CRC-32" level="-1" id="0xBF" type="binary" minver="1" webm="0">The CRC is computed on all the data of the Master element it's in. The CRC element should be the first in it's parent master for easier reading. All level 1 elements should include a CRC-32. The CRC in use is the IEEE CRC32 Little Endian</element>
  <element name="SignatureSlot" level="-1" id="0x1B538667" type="master" multiple="1" webm="0">Contain signature of some (coming) elements in the stream.</element>
  <element name="SignatureAlgo" level="1" id="0x7E8A" type="uinteger" webm="0">Signature algorithm used (1=RSA, 2=elliptic).</element>
  <element name="SignatureHash" level="1" id="0x7E9A" type="uinteger" webm="0">Hash algorithm used (1=SHA1-160, 2=MD5).</element>
  <element name="SignaturePublicKey" level="1" id="0x7EA5" type="binary" webm="0">The public key to use with the algorithm (in the case of a PKI-based signature).</element>
  <element name="Signature" level="1" id="0x7EB5" type="binary" webm="0">The signature of the data (until a new.</element>
  <element name="SignatureElements" level="1" id="0x7E5B" type="master" webm="0">Contains elements that will be used to compute the signature.</element>
  <element name="SignatureElementList" level="2" id="0x7E7B" type="master" multiple="1" webm="0">A list consists of a number of consecutive elements that represent one case where data is used in signature. Ex: <i>Cluster|Block|BlockAdditional</i> means that the BlockAdditional of all Blocks in all Clusters is used for encryption.</element>
  <element name="SignedElement" level="3" id="0x6532" type="binary" multiple="1" webm="0">An element ID whose data will be used to compute the signature.</element>

  <!-- Mide format global tags. Support required for all .mide schemas. -->
  <!-- Since the generating device may be very memory-constrained, and these tags may be repeated periodically for streaming, we use a short (global) element ID and generally allow them at any level -->
  <element name="SchemaID" level="-1" id="0xFE" type="uinteger" minver="1">Device EBML schema (aka 'tagset') hint. Points to a numeric schema ID defined at the receiving side.</element>
  <element name="Sync" level="-1" id="0xFA" type="binary" minver="1">Used to provide an arbitrary length sync word (for network / stream framing purposes) at any point in the stream.</element>  
  <!--<element name="Discontinuity" level="-1" id="0xFD" type="binary" minver="1">Probably replaced by a flag in individual datablocks at the Channel level.</element>  -->
  <element name="ElementTag" level="-1" id="0xFC" type="integer" minver="1">Arbitrary tag. Allow for separate opening and closing tags without knowing the length of the enclosed data in advance. I.e. instead of [tag len value=[subtag len... /]/], [tag len=0][subtags and contents][/tag]. Positive value corresponds to the corresponding ElementID as an opening tag; the corresponding negative value as the closing tag. Value -int_max for any int size is reserved.</element> 

  <!-- 
	VR gen3 (Slam Stick / WVR) tags 
	===============================
	
	Quick n dirty ElementID convention: 
	
	* Global tags and data that will be written frequently and during live recording will use Class A IDs (0x80 ~ 0xFF)
	* The frequently-written data mainly includes (S)CDBs and any valid children of (S)CDB, such as timecode formats. 
	* Since the number of IDs is small, we'll make no convention about human-readability whatsoever and allocate fixed blocks of address space for specific types of element. 
	* Completely made-up convention: For any 16-element master tag reservation, the child tag reservation will begin at (master tag reservation base + 0x10). 
	    0xFx (0xF0 ~ 0xFF): MIDE-defined global tags, except for SYNC, and reserved value (0xFF). No master tags. 
	    0xAx (0xA0 ~ 0xAF): Datablock formats (ChannelDataBlock, SimpleChannelDataBlock). Child elements are 0xBX... 
	    0xBx (0xB0 ~ 0xBE): Datablock child elements (mainly timestamp formats) 
	    NOTE: 0xEC and 0xBF are defined by the EBML standard, so they don't conform to the above and we can't move them either. 
	
	
	Elements NOT written during live recording should use Class B or larger IDs. 
	These include the RecordingProperties (data describing the channels and any calibration, etc.), configfile elements, etc. 
	Matroska/WebM seem to follow a convention of making these larger IDs correspond to human-readable ASCII codes where possible. The address space is so large, it seems to make more sense than choosing them completely at random. 
	  Class B (0x40 ~ 0x7F 0xXX) encoded first byte includes all of the alphanumerics (A-Z, a-z); so up to 2-byte readable codes are possible. 
	  Class C (0x20 ~ 0x3F 0xXX 0xXX) encoded first byte is comprised entirely of printable characters, including space and the numerals.  
	  Class D (0x10 ~ 0x1F 0xXX 0xXX 0xXX) encoded first byte comprises entirely NON-printable (control) characters. Most hexeditors will print them all as a dot, so the exact choice for the first byte is arbitrary. 
	
	TODO: Carve up each address space to prevent overlaps due to limitations in the python-ebml schema format (each ElementID can have only one name, datatype, etc.) 
	    Class D (4-byte IDs): 
	        [0x1A xx xx xx]  1A 45 DF A3 is used to contain EBML header 
	        [0x18 xx xx xx]  18 53 80 67 is used in Matroska/Mide to define the start of a segment/session. Propose reserving [0x18 xx xx xx] for top-level elements within a file (Session, RecordingProperties, ...) 
	    Class C (3-byte IDs): 
	        None used yet? 
	    Class B (2-byte IDs):  
	        0x42 0xXX ("B") seem to be used in the EBML header itself. 
	        0x43 0xXX ("C") we reserve for configuration-file children. 
	        0x4B 0xXX ("K") we reserve for calibration elements. 
	        0x52-0x53 0xXX ("R", "S") we reserve for represational data (RecordingProperties children).
	        0x54 0xXX ("T") we reserve for time-related data. 
            0x61 0xXX ("a") we reserve for arbitrary attributes, primarily related to drawing.
	
   -->
  
  
  <!-- Elements of the RecordingProperties branch (representational/metadata) of the file -->
  
    <element name="RecordingProperties" level="0" id="0x18526570" type="master" mandatory="0" multiple="0" minver="1">Master element for the RecordingProperties branch of the file, if present.</element>  
		<element name="RecorderInfo" level="1" id="0x5210" type="master" mandatory="0" multiple="0" minver="1">Master element for the RecorderInfo items (ID, etc.).</element>  
			<!-- NOTE: Several of the RecorderInfo tags are pulled from the Manifest and regurgitated here with a new tag ID to comply with this schema. -->
			<element name="RecorderTypeUID" level="2" id="0x5211" type="uinteger" mandatory="0" multiple="0" minver="1">Unique Type ID assigned to each recorder variation. May be used to lookup remaining RecordingProperties when streaming.</element>
			<element name="RecorderSerial" level="2" id="0x5212" type="uinteger" mandatory="0" multiple="0" minver="1">Recorder unique serial number</element>
			<element name="ProductName" level="2" id="0x5214" type="string" mandatory="0" multiple="0" minver="1">Product designation of the recording device</element>
			<element name="UserDeviceName" level="2" id="0x5215" type="string" mandatory="0" multiple="0" minver="1">Text name of this recorder, if any. Probably set by the user.</element>
			<element name="HwRev" level="2" id="0x5216" type="uinteger" mandatory="0" multiple="0" minver="1">Hardware revision level</element>
			<element name="FwRev" level="2" id="0x5217" type="uinteger" mandatory="0" multiple="0" minver="1">Firmware revision level</element>
			<element name="PartNumber" level="2" id="0x5218" type="string" mandatory="0" multiple="0" minver="1">Device part .number. (text product identifier e.g. VR002-100-XYZ).</element>
			<element name="DateOfManufacture" level="2" id="0x5219" type="uinteger" mandatory="0" multiple="0" minver="1">Device .birthdate. (manufacture date) in UTC seconds since the Epoch.</element>
			<element name="HwCustomStr" level="2" id="0x521A" type="string" mandatory="0" multiple="0" minver="1">Custom hardware identifier. Hardware is a custom version if present.</element>
			<element name="FwCustomStr" level="2" id="0x521B" type="string" mandatory="0" multiple="0" minver="1">Custom firmware build. Firmware is a custom build if present. Name should match FW branch/tag name as applicable for identification purposes, but is mainly present so FW updater can generate a warning if a custom build will be replaced by a standard one.</element>
			<element name="FwRevStr" level="2" id="0x521C" type="string" mandatory="0" multiple="0" minver="1">Firmware revision string.</element>

        <!-- SensorList and PlotList are optional; there are defaults that will be used. The use of defaults is all-or-nothing; the file should define all sensors or have no SensorList at all. -->
		<element name="SensorList" level="1" id="0x5240" type="master" mandatory="0" multiple="0" minver="2">Master element for the SensorList items</element>
			<element name="Sensor" level="2" id="0x5241" type="master" mandatory="0" multiple="1" minver="2">Master element for a Sensor entry</element>
				<element name="SensorID" level="3" id="0x5242" type="uinteger" mandatory="0" multiple="0" minver="2">ID of a given Sensor entry; can be used to refer back to this sensor.</element>
				<element name="SensorName" level="3" id="0x5243" type="string" mandatory="0" multiple="0" minver="2">Text name assigned to a sensor; probably the sensor make/model if present.</element>
				<element name="SensorBwLimitIDRef" level="3" id="0x5244" type="uinteger" mandatory="0" multiple="0" minver="2">Reference to a BwLimitList entry. If present, this discloses the usable bandwidth range of the sensor itself.</element>
				<element name="TraceabilityData" level="3" id="0x5250" type="master" mandatory="0" multiple="0" minver="2">Master element for any traceability data tied to the Sensor.</element>
					<element name="SensorSerialNumber" level="4" id="0x5251" type="string" mandatory="0" multiple="0" minver="2">Sensor manufacturer-supplied serial number, if any.</element>
					<!-- Child elements TBD... -->

        <element name="ChannelList" level="1" id="0x5270" type="master" mandatory="0" multiple="0" minver="2">Master element for a Channel entry</element>
            <element name="Channel" level="2" id="0x5271" type="master" mandatory="0" multiple="1" minver="2">Master element for a Channel entry</element>
                <element name="ChannelID" level="3" id="0x5272" type="uinteger" mandatory="0" multiple="0" minver="2">ID of a given Channel entry; can be used to refer to this entry. Referenced by ChannelDataBlock/SimpleChannelDataBlock/etc.</element>
                <element name="ChannelName" level="3" id="0x5273" type="string" mandatory="0" multiple="0" minver="2">Descriptive overall text name for this channel (e.g. "ADC").</element>
                <element name="ChannelCalibrationIDRef" level="3" id="0x5274" type="uinteger" mandatory="0" multiple="0" minver="2">Reference to a Calibration in CalibrationList.</element>
                <element name="ChannelFormat" level="3" id="0x5275" type="string" mandatory="0" multiple="0" minver="2">Declaration of the format and representation of the (sub)channels' data. Modeled after Python Struct format strings, may be expanded at a later date. Currently limited to the expanded format-string format, i.e. [>HHHHH] rather than [>5H]. Whitespace and undefined formatting characters are ignored.</element>
                <element name="ChannelParser" level="3" id="0x5276" type="string" mandatory="0" multiple="0" minver="2">Name of the hardcoded parsing object, if known. Overrides ChannelFormat.</element>

                <element name="TimeCodeScale" level="3" id="0x5277" type="string" mandatory="0" multiple="0" minver="2">Channel seconds/tick. String represents a valid numeric expression, such as integer, decimal or ratio, e.g. '16262/32768'. Applies to all subsequent Abs timecodes. If not set, use channel default.</element>
                <element name="TimeCodeModulus" level="3" id="0x5278" type="uinteger" mandatory="0" multiple="0" minver="2">The modulus at which modulo timestamps for this channel roll over.</element>
                <element name="SampleRate" level="3" id="0x5279" type="string" mandatory="0" multiple="0" minver="2">The samplerate for this channel, if known and fixed. String represents a valid numeric expression, such as integer, decimal or ratio, e.g. '32768/16262'. Element required if both starting and ending timecodes will ever be omitted for blocks in this channel.</element>
                <element name="SubChannel" level="3" id="0x52A0" type="master" mandatory="0" multiple="1" minver="2">Master element for SensorSubChannels.</element>
                    <element name="SubChannelID" level="4" id="0x52A1" type="integer" mandatory="0" multiple="0" minver="2">ID of this SubChannel. Currently, SubChannelIDs must be sequential, starting from 0, for use with Slam Stick Lab.</element>
                    <element name="SubChannelName" level="4" id="0x52A2" type="string" mandatory="0" multiple="0" minver="2">Display name of the subchannel, typically the axis name for multiaxis measurements (e.g. "X", "Yaw", etc.). Typically omitted if no display name is needed beyond a measurement label and units.</element>
                    <element name="SubChannelCalibrationIDRef" level="4" id="0x52A3" type="uinteger" mandatory="0" multiple="0" minver="2">Reference to a Calibration in CalibrationList.</element>
                    <element name="SubChannelBwLimitIDRef" level="4" id="0x52A4" type="uinteger" mandatory="0" multiple="0" minver="2">Reference to a BwLimitList entry. If present, this discloses any bandwidth limitations imposed for the acquisition channel, e.g. antialias or other filter settings. Note that the effective bandwidth is the lesser of the Sensor and SubChannel bandwidth!</element>
                    <element name="SubChannelLabel" level="4" id="0x52A5" type="string" mandatory="0" multiple="0" minver="2">General measurement type label for this subchannel (e.g. "Acceleration", "Rotation", "Temperature", etc.).</element>
                    <element name="SubChannelUnits" level="4" id="0x52A6" type="utf-8" mandatory="0" multiple="0" minver="2">Text name of the engineering unit (e.g. "g") for this subchannel. Unicode characters such as degree or Greek symbols are allowed and encouraged.</element>
                    <element name="SubChannelRangeMin" level="4" id="0x52A7" type="uinteger" mandatory="0" multiple="0" minver="2">Minimum valid sensor value; may be used for data validation or initial axis scaling during display.</element>
                    <element name="SubChannelRangeMax" level="4" id="0x52A8" type="uinteger" mandatory="0" multiple="0" minver="2">Maximum valid sensor value; may be used for data validation or initial axis scaling during display.</element>
                    <element name="SubChannelSensorRef" level="4" id="0x52A9" type="uinteger" mandatory="0" multiple="0" minver="2">Reference to a Sensor ID. Allows the association between SubChannels and a physical sensor to be expressed.</element>
                    <element name="SubChannelWarningRef" level="4" id="0x52AA" type="uinteger" mandatory="0" multiple="1" minver="2">Reference to a warning range, i.e. another sensor measuring something that affects the results of this one.</element>
                    <element name="SubChannelVisibility" level="4" id="0x52AB" type="integer" mandatory="0" multiple="0" minver="2">Allow data channels to specify a visibility level; could have different visibility levels for e.g. 'advanced', 'on request' (channels which are not normally useful on their own, e.g. IRIG stream), 'hidden' (internal diagnostic or other dirty laundry).</element>

            <element name="PlotList" level="2" id="0x5300" type="master" mandatory="0" multiple="0" minver="2">Master element for the PlotList items. It works like a virtual Channel, with Plots being its Subchannels.</element>
                <element name="Plot" level="3" id="0x5301" type="master" mandatory="0" multiple="1" minver="2">Master element for a Plot entry</element>
                    <!-- NOTE: ElementIDs/names are intentionally replicated between SubChannel and Plot children. -->
                    <element name="SubChannelID" level="4" id="0x52A1" type="integer" mandatory="0" multiple="0" minver="2">SubChannelID</element>
                    <element name="SubChannelName" level="4" id="0x52A2" type="string" mandatory="0" multiple="0" minver="2">Text name of the subchannel (e.g. axis?).</element>
                    <element name="SubChannelCalibrationIDRef" level="4" id="0x52A3" type="uinteger" mandatory="0" multiple="0" minver="2">Reference to a Calibration in CalibrationList.</element>
                    <element name="SubChannelRangeMin" level="4" id="0x52A7" type="uinteger" mandatory="0" multiple="0" minver="2">Minimum valid sensor value.</element>
                    <element name="SubChannelRangeMax" level="4" id="0x52A8" type="uinteger" mandatory="0" multiple="0" minver="2">Maximum valid sensor value.</element>
                    <element name="SubChannelWarningRef" level="4" id="0x52AA" type="uinteger" mandatory="0" multiple="1" minver="2">Reference to a warning range, i.e. another sensor measuring something that affects the results of this one</element>
                    <!--SubChannelVisibility applicable here? -->
                    <!--SubChannelBwLimitIDRef applicable here? -->
                    <!-- Elements unique to Plot -->
                    <element name="SubChannelAxisName" level="4" id="0x5302" type="string" mandatory="0" multiple="0" minver="2">Text name of the axis(?).</element>
                    <element name="SubChannelAxisXRef" level="4" id="0x5303" type="uinteger" mandatory="0" multiple="0" minver="2">Reference to an Axis.</element>
                    <element name="SubChannelUnitsName" level="4" id="0x5304" type="string" mandatory="0" multiple="0" minver="2">Text name of the sensor output units.</element>
                    <element name="SubChannelUnitsXRef" level="4" id="0x5305" type="uinteger" mandatory="0" multiple="0" minver="2">Reference to a numbered, standardized SI unit.</element>

                    <element name="PlotSource" level="4" id="0x5320" type="master" mandatory="0" multiple="1" minver="2">List of channels/subchannels used by this Plot</element>
                        <element name="PlotChannelRef" level="5" id="0x5221" type="integer" mandatory="0" multiple="0" minver="2">SubChannelID</element>
                        <element name="PlotSubChannelRef" level="5" id="0x5222" type="integer" mandatory="0" multiple="0" minver="2">SubChannelID</element>
                        
            <element name="WarningList" level="1" id="0x5360" type="master" mandatory="0" multiple="0" minver="2"> "Idiot Light" warnings for sensors that are inaccurate in certain conditions </element>
                <element name="Warning" level="2" id="0x5361" type="master" mandatory="0" multiple="1" minver="2"> </element>
                    <element name="WarningID" level="3" id="0x5362" type="integer" mandatory="0" multiple="0" minver="2">Warning ID, referenced by Subchannels. </element>
                    <element name="WarningChannelRef" level="3" id="0x5363" type="integer" mandatory="0" multiple="0" minver="2">ChannelID</element>
                    <element name="WarningSubChannelRef" level="3" id="0x5364" type="integer" mandatory="0" multiple="0" minver="2">SubChannelID</element>
                    <element name="WarningRangeMin" level="3" id="0x5365" type="float" mandatory="0" multiple="0" minver="2">Minimum valid value. Note: this is in real, post-converted units, not raw channel units. </element>
                    <element name="WarningRangeMax" level="3" id="0x5366" type="float" mandatory="0" multiple="0" minver="2">Maximum valid value. Note: this is in real, post-converted units, not raw channel units. </element>

            <element name="BwLimitList" level="1" id="0x5380" type="master" mandatory="0" multiple="0" minver="2"> List of bandwidth constraints on sensors and data channels. These will (on a Sensor) provide the intrinsic sensor limits if known, or (on a data channel) provide information about any user-configured limits, e.g. AA filter cutoffs. This data is mandatory for sensor fusion, otherwise optional.</element>
                <element name="BwLimit" level="2" id="0x5381" type="master" mandatory="0" multiple="1" minver="2"> </element>
                    <element name="BwLimitID" level="3" id="0x5382" type="integer" mandatory="0" multiple="0" minver="2">Limit entry ID, referenced by Sensors or (Sub)channels. </element>
                    <element name="LowerCutoff" level="3" id="0x5383" type="string" mandatory="0" multiple="0" minver="2">Lower cutoff frequency.</element>
                    <element name="LowerRolloff" level="3" id="0x5384" type="string" mandatory="0" multiple="0" minver="2">Lower rolloff, in dB/decade.</element>
                    <element name="UpperCutoff" level="3" id="0x5385" type="string" mandatory="0" multiple="0" minver="2">Upper cutoff frequency.</element>
                    <element name="UpperRolloff" level="3" id="0x5386" type="string" mandatory="0" multiple="0" minver="2">Upper rolloff, in dB/decade.</element>
                    <element name="GroupDelay" level="3" id="0x5387" type="string" mandatory="0" multiple="0" minver="2">Group delay, in channel ticks (channels/subchannels only).</element>
                    
    <!-- 
    Attributes: a way to insert an arbitrary key/value into a structure, without revising (and potentially bloating) the schema itself. This data is typically non-critical.
    Strictly speaking, this may be considered an abuse of EBML, but it is flexible and moderately clean.
    -->
    <element name="Attribute" level="-1" id="0x6110" type="master" mandatory="0" multiple="1" minver="2"> Container For arbitrary name/value attributes, allowing additional data without revising (and bloating) the schema. All of these elements are level -1, allowing an AttributeList to occur at any level, but should always be used at the relative levels implied below. </element>
        <element name="AttributeName" level="1" id="0x612f" type="utf-8" mandatory="0" multiple="0" minver="2"> Attribute name. Should always be child of Atrribute. </element>
        <element name="IntAttribute" level="1" id="0x6120" type="integer" mandatory="0" multiple="0" minver="2"> Integer Attribute. Should always be child of Atrribute. </element>
        <element name="UIntAttribute" level="1" id="0x6121" type="uinteger" mandatory="0" multiple="0" minver="2"> Unsigned integer Attribute. Should always be child of Atrribute. </element>
        <element name="FloatAttribute" level="1" id="0x6122" type="float" mandatory="0" multiple="0" minver="2"> Floating point Attribute. Should always be child of Atrribute. </element>
        <element name="StringAttribute" level="1" id="0x6123" type="string" mandatory="0" multiple="0" minver="2"> ASCII String Attribute. Should always be child of Atrribute. </element>
        <element name="DateAttribute" level="1" id="0x6124" type="date" mandatory="0" multiple="0" minver="2"> Date Attribute. Should always be child of Atrribute. </element>
        <element name="BinaryAttribute" level="1" id="0x6125" type="binary" mandatory="0" multiple="0" minver="2"> Binary Attribute. Should always be child of Atrribute. </element>


	<!-- 
	Calibration entries. Any dynamically-generated data pertaining to plotting or syncing channels will eventually be written here. These are stored top-level to minimize the memory footprint of any device-side reprocessing of these entries. 

	Each calibration entry in the CalibrationList will be either a UnivariatePolynomial OR a BivariatePolynomial. The level-2 entries below are actually shared between these master types. 
	In the case of a BivariatePolynomial, the BivariateChannelIDRef and BivariateSubChannelIDRef are mandatory.
	
	The calibration entry types and their coefficient blocks specify an n-degree univariate or bivariate polynomial, respectively. 

	Univariate: Evaluated in the form y = sum( A(x-xref)^n ) for all n, where y is the output sample, A is the coefficient, x is the input sample, xref is the reference value, n is the degree of each term and the terms are expressed from highest to lowest degree. 
	Examples: 
	   2 coef block [A B]: y = A(x-xref) + B 
	   4 coef block [A B C D]: y = A(x-xref)^3 + B(x-xref)^2 + C(x-xref) + D 

	Bivariate: Evaluated in the form y = sum( A(x-xref)^m(y-yref)^n ) for all m and n, where: 
	y is the output sample, 
	A is the coefficient, 
	x,y are the input samples for this and the 2nd channel, 
	xref,yref are the reference values for this and the 2nd channel, 
	m,n are the degrees of the x and y terms. 
	Ordering here is a little trickier: for any degree, a term must exist for every permutation the degrees 0~n for x and y, e.g. x^2y^2, x^2y, xy^2, xy, ... 
	Terms are expressed  from highest to lowest total degree (m*n), with terms of equal degree sorted by degree of the 1st channel term (for example, x^2y^1 would come before x^1y^2), assuming the 1st channel term is always expressed first. 
	Due to the permutation, legal coefficient block lengths are those which satisfy the number of permuted terms, or generally, nCoefs=(degree+1)^2 . (FIXME: CHECKME: Valid up to 2nd order; have not checked further...) 
	
	Examples: 
	   degree 0: 1 coef block [A] (trivial case for completeness): y = A(x-xref)^0(y-yref)^0 = A 
	   degree 1: 4 coef block [A B C D]: A(x-xref)(y-yref) + B(x-xref) + C(y-yref) + D  
	-->
	
	<!-- Rules: This should appear after the Recording properties element (more specifically, after SensorList and PlotList), if one exists and the Bivariate polynomials reference non-default (sub)channels. -->
	
	<element name="CalibrationList" level="0" id="0x4B00" type="master" mandatory="0" multiple="0" minver="1">Master element for the CalibrationList items</element>
		<element name="UnivariatePolynomial" level="1" id="0x4B01" type="master" mandatory="0" multiple="1" minver="1">Master element for a univariate (1-variable) calibration entry</element>
			<element name="CalID" level="2" id="0x4B03" type="uinteger" mandatory="1" multiple="0" minver="1">ID of this entry, referenced by SensorList.</element>
			<element name="CalReferenceValue" level="2" id="0x4B04" type="float" mandatory="0" multiple="0" minver="1">Reference value for this channel</element>
			<element name="PolynomialCoef" level="2" id="0x4B08" type="float" mandatory="0" multiple="1" minver="1">Univariate or bivariate polynomial coefficient in canonical order</element>			
		<element name="BivariatePolynomial" level="1" id="0x4B02" type="master" mandatory="0" multiple="1" minver="1">Master element for a bivariate (2-variable) calibration entry</element>
			<element name="CalID" level="2" id="0x4B03" type="uinteger" mandatory="1" multiple="0" minver="1">ID of this entry, referenced by SensorList.</element>
			<element name="CalReferenceValue" level="2" id="0x4B04" type="float" mandatory="0" multiple="0" minver="1">Reference value for this channel</element>
			<element name="BivariateCalReferenceValue" level="2" id="0x4B05" type="float" mandatory="0" multiple="0" minver="1">Reference value for the 2nd channel when using bivariate calibration</element>
			<element name="BivariateChannelIDRef" level="2" id="0x4B06" type="uinteger" mandatory="0" multiple="0" minver="1">Channel ID of the channel to be used as the 2nd parameter for bivariate compensation</element>
			<element name="BivariateSubChannelIDRef" level="2" id="0x4B07" type="uinteger" mandatory="0" multiple="0" minver="1">SubChannel ID of the subchannel to be used as the 2nd parameter for bivariate compensation</element>
			<element name="PolynomialCoef" level="2" id="0x4B08" type="float" mandatory="0" multiple="1" minver="1">Univariate or bivariate polynomial coefficient in canonical order</element>			
		<element name="CalibrationDate" level="1" id="0x4B20" type="uinteger" mandatory="0" multiple="0" minver="1">Date of factory calibration, in UTC seconds</element>
		<element name="CalibrationExpiry" level="1" id="0x4B22" type="uinteger" mandatory="0" multiple="0" minver="1">Date of factory calibration expiration, in UTC seconds</element>
		<element name="CalibrationSerialNumber" level="1" id="0x4B21" type="uinteger" mandatory="0" multiple="0" minver="1">Mide-assigned serial # for a specific (re)calibration procedure. Can be used to lookup calibration conditions and exact facility / test stand used, etc.</element>

  <!-- Elements of a configuration file -->
    <!-- This is stuck into the main schema for convenience, but really it has no relation. If the configfile were to be attached to a recording as metadata, it would be as a binary blob - the 'Level's need not be consistent with the recording file. -->
	<element name="RecorderConfiguration" level="0" id="0x18436667" type="master" mandatory="0" multiple="0" minver="1">Master element for the RecorderConfiguration block, if present. This allows a mechanism to attach the actual recorder configuration to the file as metadata, and (hacky) use the same schema document to parse output files and write configuration files. It is expected that by necessity, children of RecorderConfiguration will be recorder-specific.</element>
	    <element name="SSXBasicRecorderConfiguration" level="1" id="0x4300" type="master" mandatory="0" multiple="0" minver="1">Master element for the SSX-specific RecorderConfiguration block. This and its subelements are specific to the basic Slam Stick X.</element>
			<element name="SampleFreq" level="2" id="0x4310" type="uinteger" mandatory="0" multiple="0" minver="1">Sampling frequency for the high speed channel(s) in Hz.</element>
			<element name="AAFilterCornerFreq" level="2" id="0x4311" type="uinteger" mandatory="0" multiple="0" minver="1">Antialias filter corner frequency for the high speed channel(s) in Hz. Omit to let the device choose based on the sampling rate. Enter 0 to disable (bypass) AA filter. (Beware: diagnostic usage only; calibration will be invalid in this state.)</element>
			<element name="OSR" level="2" id="0x4312" type="uinteger" mandatory="0" multiple="0" minver="1">Oversampling ratio. Allowed values are 1 or power-of-2 integer in the range from 16 to 4096. Omit to let the device choose based on the sampling rate.</element>
			<element name="UTCOffset" level="2" id="0x4313" type="integer" mandatory="0" multiple="0" minver="1">UTC offset in seconds. May be used for entering local timezone offset. Sign follows the normal convention for specifying timezone offsets, e.g. "UTC-5" (-5*3600) to display the local time as 5 hours earlier than UTC. This value is only used to convert the internal UTC time to local time to generate the FAT16/32 file timestamp, which is expected to be in local time (sans any DST offset, which is added by the host system). If the device clock is directly set in local time for any reason, this field should be 0.</element>
			<element name="PlugPolicy" level="2" id="0x4314" type="uinteger" mandatory="0" multiple="0" minver="2">Defines device behavior in response to an unexpected plug-in (or other power/data connection) during recording. Current options are 0 (exit immediately), 1 (exit after current recording finishes - HW default), or 2 (ignore - require button presses to terminate recording mode).</element>
	    <element name="SSXTriggerConfiguration" level="1" id="0x4340" type="master" mandatory="0" multiple="0" minver="1">Master element for SSX trigger configuration.</element>
			<element name="WakeTimeUTC" level="2" id="0x4350" type="uinteger" mandatory="0" multiple="0" minver="1">Absolute, calendar time in UTC at which to arm/start the recorder. WakeTimeUTC and PreRecordDelay are mutually exclusive.</element>
			<element name="PreRecordDelay" level="2" id="0x4351" type="uinteger" mandatory="0" multiple="0" minver="1">Delay in seconds before the start of recording (or trigger arming). WakeTimeUTC and PreRecordDelay are mutually exclusive.</element>
			<element name="AutoRearm" level="2" id="0x4352" type="uinteger" mandatory="0" multiple="0" minver="1">Automatically rearm at end of triggered recording (do not require button press)</element>			
			<element name="RecordingTime" level="2" id="0x4353" type="uinteger" mandatory="0" multiple="0" minver="1">Time in seconds to record for when triggered. Omit to impose no limit.</element>
			<!-- Some IDs reserved for specifying activity behavior, e.g. restart the RecordingTime as long as something interesting is happening -->
			<element name="Trigger" level="2" id="0x4360" type="master" mandatory="0" multiple="1" minver="1">Master element for a generic trigger.</element>
				<element name="TriggerChannel" level="3" id="0x4361" type="integer" mandatory="0" multiple="0" minver="1">The sensor channel used as the trigger. Mandatory for all Triggers.</element>
				<element name="TriggerSubChannel" level="3" id="0x4362" type="integer" mandatory="0" multiple="0" minver="1">The sensor subchannel used by the trigger.</element>
				<element name="TriggerWindowLo" level="3" id="0x4363" type="integer" mandatory="0" multiple="0" minver="1">Lower value of trigger window in native units.</element>
				<element name="TriggerWindowHi" level="3" id="0x4364" type="integer" mandatory="0" multiple="0" minver="1">Upper value of trigger window in native units.</element>
	    <element name="SSXChannelConfiguration" level="1" id="0x43A0" type="master" mandatory="0" multiple="1" minver="2">Master element for channel-specific configuration elements.</element>
			<element name="ConfigChannel" level="2" id="0x43A1" type="uinteger" mandatory="1" multiple="0" minver="2">Channel to apply these configuration elements to.</element>
			<element name="ChannelSampleFreq" level="2" id="0x43A2" type="uinteger" mandatory="0" multiple="0" minver="2">Sampling frequency for this channel in Hz, if supported by device. Unsupported rates will be coerced to nearest supported rate.</element>
			<element name="SubChannelEnableMap" level="2" id="0x43A3" type="uinteger" mandatory="0" multiple="0" minver="2">Bitmap indicating enabled/disabled SubChannels, if supported by device. If only Channel-level enable/disable supported by this channel, any nonzero value will enable the entire Channel.</element>			
        <element name="RecorderUserData" level="1" id="0x43F0" type="master" mandatory="0" multiple="0" minver="1">The user-defined properties of the recorder, not used by the recorder itself.</element>
            <element name="RecorderName" level="2" id="0x43F1" type="utf-8" mandatory="0" multiple="0" minver="1">The user-defined name of the recorder</element>
            <element name="RecorderDesc" level="2" id="0x43F2" type="utf-8" mandatory="0" multiple="0" minver="1">The user-defined description of/notes on the recorder</element>




  <!-- Elements of the actual recording(s) (Session branch(es) of the file) -->
  
  <element name="Session" level="0" id="0x18538067" type="master" multiple="1" minver="1">This element contains all other top-level (level 1) elements. A session basically comprises one 'recording' and may contain any number of individual channels. A typical file should consist of one segment (mostly because we won't really know its length in advance).</element>

  <!-- 
    Children of Session. However, since we may implement Session tags as being completely optional / nonexistent / polite suggestion on the reader side, take 'Level' with a grain of salt...

	 Some notes on timecode stuff
	 
		 Timecoding is vitally important to most data acquisition, so it's OK if these proliferate a bit... 
		 TimecodeScales should be set *per channel*, and may use the default value ONLY if none declared for the channel! 
		 For WVR / Slam Stick we'll use TimeBaseUTC, TimeCodeAbs, TimeCodeAbsMod. Any other timecode formats effectively don't exist until we need them... 
		 TimeBase: A base time (Unix time stamp in seconds) applied in the Session. All future session timecodes are an offset from the last known TimeBase. Most likely a file will contain only a single TimeBase element at the start of the session. 
		 TimeCode: Offset from the TimeBase; its scale is defined by a TimeCodeScale element on a per-channel basis (with 32768 ticks/sec as a default). The possible permutations are... 
		     Start/End: The TimeCode may correspond to the first sample in the block (start) or the last sample in the block (end). 
		     Abs/AbsMod/(Relative): The TimeCode may be absolute, modulo, or relative (not implemented). Absolute shall increase monotonically for the duration of the session and must be sized large enough to express any reasonably expected session length. Modulo timecodes are allowed to roll over at the UINT_MAX for a given number of octets. 
		 In a typical application, the Session would start with a single TimeBase (probably overflows of a device's internal high-res clock, in seconds), immediately followed by a Session-level TimeCodeAbs(Mod) with the sub-second count from the same oscillator, captured at the same time as the seconds (to avoid any possible unhandled rollovers between the TimeBase and the first sample from individual channels), or a dummy zero-length *ChannelDataBlock for each channel if Session-level TimeCodes not allowed.  
	
	 Rules for generated files / streams 
	 
		 General 
			 The file/stream MAY contain tags not recognized by the viewer (e.g. for internal debugging or defined after a given viewer / schema version was released). The viewer is expected to skip the unrecognized data without crashing. The viewer MAY inform the user that unrecognized data is present, but isn't required to. 
			 Files may contain any global tag defined by the EBML standard, including VOID tags, at any document level. 
			 Length-encoded EBML data may encode length data using any number of bytes equal or greater than the minimum required to encode the value. For example, a length of 1 may be encoded as 0x81 or 0x4001 or 0x200001, etc. ("Gassy" encodings may be used by the device to enforce memory alignment or consume slack bytes in a fixed buffer allocation, etc.) 
			 If the Schema or RecorderProperties are unavailable for any reason, the reader MAY substitute its best guess for this data, such as a default copy based on some signal (device ID, etc.). No guaranteees can be made about the ability of a given reader to parse a given file if these data are not present in the file. In the case of a Stream, the reader is free to ignore/discard all data received before both a SYNC tag and a reference to a valid Schema/RecordingProperties are received. (Really, there are no guarantees about anyone receiving or parsing the streamed data, period.) 
			 For the time being, devices SHALL NOT write files consisting of multiple sessions, and must assume any representation of sessions in the file may be ignored. For the time being (forseeable future), the reader MAY define child elements of Session (datablocks, etc.) to actually be siblings. 
	
	 Rules for channels 
	 
		 General 
			 Although expressed as a signed type, channels written by the device must be positive. Negative channel numbers are reserved (may be used by the reader for e.g. virtual channels consisting of processed data). 
			 Channel numbering is arbitrary and is not necessarily consecutive. 
			 The device MAY list channels in its RecorderProperties that have no datablocks associated with them. (The channel information may be hardcoded and channels may appear for sensors that are disabled in the current configuration or aren't populated on the device.) 
			 The device SHOULD NOT generate datablocks for channels that do not have a corresponding entry in RecorderProperties. The behavior of the reader upon encountering such channels is undefined. (A nice response would be to silently ignore them, but it could just crash, and it's your own damn fault, dear firmware writer.) 
	
	 Rules for datablocks 
	
		 General 
			 The device MAY (and often will) use different block types for different channels. Most commonly, full CDBs for data taken at high rates and/or precise timing requirements, and a 'Simple' blocktype (e.g. SCDB) for low-rate channels consisting of only a few or single samples. The device MAY mix block types in a single channel. (It probably won't, but is not expressly forbidden from doing so.) 
			 As a point of clarification, if the device mixes blocktypes in a channel, the types MAY use different timecode formats, and modulo timecodes may have different moduli. The usual rules below still apply - the device may not 'lose' rollovers. 
	
		 Datablock timecoding rules: 
			 General 
				 The timecode scale, representation and modulus is allowed to differ between channnels, so accounting for rollovers in modulo timestamps should be handled per-channel. 
				 Where modulo timestamps are used, the device MUST NOT allow more than one rollover period to elapse between blocks in a given channel. In the case of long gaps between datablocks in a channel, the device MUST either write a datablock using a timecode format large enough to correctly represent the time elapsed, OR write one or more dummy (zero-sample) datablocks such that all rollovers are "caught up" before the next datablock sample. 
				 If a Start and End timecode are provided, the Start timecode is the time of the first sample in the block; the End timecode is the time of the last sample in the block. For formats that provide only a single timecode, it corresponds to the first sample in the block. 
	
			 Modulo timecodes and mixing of timecodes 
				 The modulus is defined as the exact value *at* which a given value is equal to zero. In other words, it is one more than the maximum possible remainder value. For example, a 16-bit timecode with a maximum legal value of 0xFFFF has a modulus of 0x10000. 
				 A modulo timecode has rolled over if the current value is LESS THAN the previous value. Given two consecutive datablocks with identical modulo timecode 'n', no time has elapsed between them. Given two blocks with timecodes n and n-1, respectively, the maximum allowable time for the timecode's modulus has elapsed. 
	
			 Timecode ordering 
				 Timecodes in the datablocks written for a given channel MUST be monotonically increasing. That is, the device MUST NOT write a datablock for a given channel with an earlier timecode than an already written datablock for that channel. It can be safely assumed that a decrease in any modulo timecode represents a rollover, and any decrease in a non-modulo absolute timecode is an error condition. (This is a litter stricter than Matroska, which allows out-of-order timecodes as long as elements referencing another element's timecode come after said referenced element. The monotonicity requirement is to allow random-access seeking time ranges within the files.) 
				 However, datablocks are NOT required to be monotonically increasing ACROSS channels. 
				 In other words, given an output such as: <datablock1 ch=1> <datablock2 ch=2> <datablock3 ch=1>, datablock2 may have an earlier timecode than datablock1 (because they are different channels), but datablock3 may not (same channel). 
	-->

  <element name="TimeBaseUTC" level="0" id="0x5462" type="uinteger" mandatory="0" multiple="1" minver="1">Session time base value in Unix Time. If present, used as the base for all future timecodes in the session.</element>

  <element name="SimpleChannelDataBlock" level="0" id="0xA0" type="binary" multiple="1" minver="1">This element contains potentially-channelized instrumentation data in a minimalist format. Its mandatory, fixed-length header includes a 2-byte modulo timecode (scaled to the channel's TimecodeScale, default of 1/32768 sec) and a 1-byte integer ChannelID.</element>

  <element name="ChannelDataBlock" level="0" id="0xA1" type="master" multiple="1" minver="1">This element contains child elements including instrumentation data associated to a channel. This is used for e.g. binding a timestamp(s) and/or metadata to a specific multi-sample block of sensor data, which may be written asynchronously with respect to other channels' data (i.e. multiplexed).</element>
	  <element name="ChannelIDRef" level="1" id="0xB0" type="integer" multiple="0" minver="1">Child of ChannelDataBlock: the channel this data is associated with</element>
	  <element name="ChannelFlags" level="1" id="0xB1" type="uinteger" multiple="0" minver="1">Child of ChannelDataBlock: optional flags to indicate datablock features such as discontinuity</element>
	  <element name="ChannelDataPayload" level="1" id="0xB2" type="binary" multiple="0" minver="1">Child of ChannelDataBlock: the actual channel data samples. If there are multiple subchannels, for each sample point, the sample for each subchannel will be written consecutively (i.e. [sc0 sc1 sc2] [sc0 sc1 sc2]).</element>
	  <element name="StartTimeCodeAbs" level="1" id="0xB8" type="uinteger" mandatory="0" multiple="0" minver="1">Absolute timecode as an offset from the session TimeBase. The timecode resolution is given by the channel's TimeCodeScale.</element>
	  <element name="EndTimeCodeAbs" level="1" id="0xB9" type="uinteger" mandatory="0" multiple="0" minver="1">Absolute timecode as an offset  from the session TimeBase. The timecode resolution is given by the channel's TimeCodeScale.</element>
	  <element name="StartTimeCodeAbsMod" level="1" id="0xBA" type="uinteger" mandatory="0" multiple="0" minver="1">Absolute start timecode as an offset from session TimeBase, mod TimeCodeModulus. Allows for a short, rolling-over (but still absolute) code. The timecode resolution is given by the channel's TimeCodeScale.</element>
	  <element name="EndTimeCodeAbsMod" level="1" id="0xBB" type="uinteger" mandatory="0" multiple="0" minver="1">Absolute end timecode as an offset from session TimeBase, mod TimeCodeModulus. Allows for a short, rolling-over (but still absolute) code. The timecode resolution is given by the channel's TimeCodeScale.</element>
	  <element name="ChannelDataMinMeanMax" level="1" id="0xBC" type="binary" multiple="0" minver="1">Statistical data for this block's payload consisting of 3 datapoints (min, mean, max) per subchannel. They are organized as [[sc0min] [sc1min] [sc2min] ...] [[sc0mean] [sc1mean] [sc2mean] ...] [[sc0max] [sc1max] [sc2max] ...]. The format and representation of the stat data exactly matches that of the input samples; that is, if the input samples are uint16_t, each stat entry is also a uint16_t.</element>
	  <element name="MediaWriteLatency" level="1" id="0xBE" type="uinteger" mandatory="0" multiple="0" minver="2">Super-optional diagnostic element indicating the latency between data acquisition and transfer to the output media. The exact meaning of this value is device-dependent, but may serve as a general indicator of excess activity load, retransmission or congestion (for transmission media) or media wear (for recording media).</element>
</table>

