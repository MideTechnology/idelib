<?xml version="1.0" encoding="utf-8"?>

<!-- The list of element parameters for this file seems to be: -->
<!-- 
name="MyElement"
(cppname)="ParentMyElement (arbitrary)"
level="0"
id="0x1234"
type="master, uinteger, integer, binary, string, utf=8, float"
mandatory="0"
multiple="0"
minver="1"
range="> 0, not 0, 1-30" ... seems to be arbitrary / probably not checked. 
bytesize="16"
default="123" or a text value that may or may not be the name of another tag

(webm)
(divx)
-->

<table>
  <!-- Base EBML elements. Required. -->
  <element name="EBML" level="0" id="0x1A45DFA3" type="master" mandatory="1" multiple="1" minver="1">Set the EBML characteristics of the data to follow. Each EBML document has to start with this.</element>
  <element name="EBMLVersion" level="1" id="0x4286" type="uinteger" mandatory="1" default="1" minver="1">The version of EBML parser used to create the file.</element>
  <element name="EBMLReadVersion" level="1" id="0x42F7" type="uinteger" mandatory="1" default="1" minver="1">The minimum EBML version a parser has to support to read this file.</element>
  <element name="EBMLMaxIDLength" level="1" id="0x42F2" type="uinteger" mandatory="1" default="4" minver="1">The maximum length of the IDs you'll find in this file (4 or less in Matroska).</element>
  <element name="EBMLMaxSizeLength" level="1" id="0x42F3" type="uinteger" mandatory="1" default="8" minver="1">The maximum length of the sizes you'll find in this file (8 or less in Matroska). This does not override the element size indicated at the beginning of an element. Elements that have an indicated size which is larger than what is allowed by EBMLMaxSizeLength shall be considered invalid.</element>
  <element name="DocType" level="1" id="0x4282" type="string" mandatory="1" default="matroska" minver="1">A string that describes the type of document that follows this EBML header. 'matroska' in our case or 'webm' for webm files.</element>
  <element name="DocTypeVersion" level="1" id="0x4287" type="uinteger" mandatory="1" default="1" minver="1">The version of DocType interpreter used to create the file.</element>
  <element name="DocTypeReadVersion" level="1" id="0x4285" type="uinteger" mandatory="1" default="1" minver="1">The minimum DocType version an interpreter has to support to read this file.</element>
  <element name="Void" level="-1" id="0xEC" type="binary" minver="1">Used to void damaged data, to avoid unexpected behaviors when using damaged data. The content is discarded. Also used to reserve space in a sub-element for later use.</element>
  <element name="CRC-32" level="-1" id="0xBF" type="binary" minver="1" webm="0">The CRC is computed on all the data of the Master element it's in. The CRC element should be the first in it's parent master for easier reading. All level 1 elements should include a CRC-32. The CRC in use is the IEEE CRC32 Little Endian</element>
  <element name="SignatureSlot" level="-1" id="0x1B538667" type="master" multiple="1" webm="0">Contain signature of some (coming) elements in the stream.</element>
  <element name="SignatureAlgo" level="1" id="0x7E8A" type="uinteger" webm="0">Signature algorithm used (1=RSA, 2=elliptic).</element>
  <element name="SignatureHash" level="1" id="0x7E9A" type="uinteger" webm="0">Hash algorithm used (1=SHA1-160, 2=MD5).</element>
  <element name="SignaturePublicKey" level="1" id="0x7EA5" type="binary" webm="0">The public key to use with the algorithm (in the case of a PKI-based signature).</element>
  <element name="Signature" level="1" id="0x7EB5" type="binary" webm="0">The signature of the data (until a new.</element>
  <element name="SignatureElements" level="1" id="0x7E5B" type="master" webm="0">Contains elements that will be used to compute the signature.</element>
  <element name="SignatureElementList" level="2" id="0x7E7B" type="master" multiple="1" webm="0">A list consists of a number of consecutive elements that represent one case where data is used in signature. Ex: <i>Cluster|Block|BlockAdditional</i> means that the BlockAdditional of all Blocks in all Clusters is used for encryption.</element>
  <element name="SignedElement" level="3" id="0x6532" type="binary" multiple="1" webm="0">An element ID whose data will be used to compute the signature.</element>

  <!-- Mide format global tags. Support required for all .mide schemas. -->
  <!-- Since the generating device may be very memory-constrained, and these tags may be repeated periodically for streaming, we use a short (global) element ID and generally allow them at any level -->
  <element name="SchemaID" level="-1" id="0xFE" type="uinteger" minver="1">Device EBML schema (aka 'tagset') hint. Points to a numeric schema ID defined at the receiving side.</element>
  <element name="Sync" level="-1" id="0xFA" type="binary" minver="1">Used to provide an arbitrary length sync word (for network / stream framing purposes) at any point in the stream.</element>  
  <!--<element name="Discontinuity" level="-1" id="0xFD" type="binary" minver="1">Probably replaced by a flag in individual datablocks at the Channel level.</element>  -->
  <element name="ElementTag" level="-1" id="0xFC" type="integer" minver="1">Arbitrary tag. Allow for separate opening and closing tags without knowing the length of the enclosed data in advance. I.e. instead of [tag len value=[subtag len... /]/], [tag len=0][subtags and contents][/tag]. Positive value corresponds to the corresponding ElementID as an opening tag; the corresponding negative value as the closing tag. Value -int_max for any int size is reserved.</element> 
  
<!-- VR gen3 (Slam Stick / WVR) tags -->


<!-- Quick n dirty ElementID convention: -->

<!-- Global tags and data that will be written frequently and during live recording will use Class A IDs (0x80 ~ 0xFF) -->
<!-- The frequently-written data mainly includes (S)CDBs and any valid children of (S)CDB, such as timecode formats. -->
<!-- Since the number of IDs is small, we'll make no convention about human-readability whatsoever and allocate fixed blocks of address space for specific types of element. -->
<!-- Completely made-up convention: For any 16-element master tag reservation, the child tag reservation will begin at (master tag reservation base + 0x10). -->
<!--     0xFx (0xF0 ~ 0xFF): MIDE-defined global tags, except for SYNC, and reserved value (0xFF). No master tags. -->
<!--     0xAx (0xA0 ~ 0xAF): Datablock formats (ChannelDataBlock, SimpleChannelDataBlock). Child elements are 0xBX... -->
<!--     0xBx (0xB0 ~ 0xBE): Datablock child elements (mainly timestamp formats) -->
<!--     NOTE: 0xEC and 0xBF are defined by the EBML standard, so they don't conform to the above and we can't move them either. -->


<!-- Elements NOT written during live recording should use Class B or larger IDs. -->
<!-- These include the RecordingProperties (data describing the channels and any calibration, etc.), configfile elements, etc. -->
<!-- Matroska/WebM seem to follow a convention of making these larger IDs correspond to human-readable ASCII codes where possible. The address space is so large, it seems to make more sense than choosing them completely at random. -->
<!--   Class B (0x40 ~ 0x7F 0xXX) encoded first byte includes all of the alphanumerics (A-Z, a-z); so up to 2-byte readable codes are possible. -->

<!--   Class C (0x20 ~ 0x3F 0xXX 0xXX) encoded first byte is comprised entirely of printable characters, including space and the numerals.  -->
<!--   Class D (0x10 ~ 0x1F 0xXX 0xXX 0xXX) encoded first byte comprises entirely NON-printable (control) characters. Most hexeditors will print them all as a dot, so the exact choice for the first byte is arbitrary. -->

<!-- TODO: Carve up each address space to prevent overlaps due to limitations in the python-ebml schema format (each ElementID can have only one name, datatype, etc.) -->
<!--     Class D (4-byte IDs): -->
<!--         [0x1A xx xx xx]  1A 45 DF A3 is used to contain EBML header -->
<!--         [0x18 xx xx xx]  18 53 80 67 is used in Matroska/Mide to define the start of a segment/session. Propose reserving [0x18 xx xx xx] for top-level elements within a file (Session, RecordingProperties, ...) -->


<!--     Class C (3-byte IDs): -->
<!--         None used yet? -->

<!--     Class B (2-byte IDs):  -->
<!--         0x42 0xXX ("B") seem to be used in the EBML header itself. -->
<!--         0x43 0xXX ("C") we reserve for configuration-file children. -->
<!--         0x52 0xXX ("R") we reserve for represational data (RecordingProperties children). Leave space after (0x53, etc.) in case we need more than 127. -->
<!--         0x54 0xXX ("T") we reserve for time-related data. -->
<!-- -->
  
  
  
  <!-- Elements of the RecordingProperties branch (representational/metadata) of the file -->
  
    <element name="RecordingProperties" level="0" id="0x18526570" type="master" mandatory="0" multiple="0" minver="1">Master element for the RecordingProperties branch of the file, if present.</element>  

  
  <!-- RecordingProperties -> SensorList -> Sensor -> SensorChannel -> these. TODO... -->
  
      <element name="TimeCodeScale" level="4" id="0x5274" type="uinteger" mandatory="0" multiple="1" minver="1">Configuration child (eventually)... Ticks/sec (n integer + 1 fractional byte), i.e. encoded as (ticks/sec)*256; decode by dividing by 256. Applies to all subsequent Abs timecodes. If not set, use channel default.</element>
  <element name="TimeCodeModulus" level="4" id="0x5275" type="uinteger" mandatory="0" multiple="1" minver="1">Configuration child (eventually)... The modulus at which modulo timestamps for this channel roll over.</element>
  
  
  <!-- Elements of the actual recording(s) (Session branch(es) of the file) -->
  
  <element name="Session" level="0" id="0x18538067" type="master" multiple="1" minver="1">This element contains all other top-level (level 1) elements. A session basically comprises one 'recording' and may contain any number of individual channels. A typical file should consist of one segment (mostly because we won't really know its length in advance).</element>



<!-- Children of Session. However, since we may implement Session tags as being completely optional / nonexistent / polite suggestion on the reader side, take 'Level' with a grain of salt...-->

<!-- Some notes on timecode stuff -->
<!-- Timecoding is vitally important to most data acquisition, so it's OK if these proliferate a bit... -->
<!-- TimecodeScales should be set *per channel*, and may use the default value ONLY if none declared for the channel! -->
<!-- For WVR / Slam Stick we'll use TimeBaseUTC, TimeCodeAbs, TimeCodeAbsMod. Any other timecode formats effectively don't exist until we need them... -->
<!-- TimeBase: A base time (Unix time stamp in seconds) applied in the Session. All future session timecodes are an offset from the last known TimeBase. Most likely a file will contain only a single TimeBase element at the start of the session. -->
<!-- TimeCode: Offset from the TimeBase; its scale is defined by a TimeCodeScale element on a per-channel basis (with 32768 ticks/sec as a default). The possible permutations are... -->
<!--     Start/End: The TimeCode may correspond to the first sample in the block (start) or the last sample in the block (end). -->
<!--     Abs/AbsMod/(Relative): The TimeCode may be absolute, modulo, or relative (not implemented). Absolute shall increase monotonically for the duration of the session and must be sized large enough to express any reasonably expected session length. Modulo timecodes are allowed to roll over at the UINT_MAX for a given number of octets. -->
<!-- In a typical application, the Session would start with a single TimeBase (probably overflows of a device's internal high-res clock, in seconds), immediately followed by a Session-level TimeCodeAbs(Mod) with the sub-second count from the same oscillator, captured at the same time as the seconds (to avoid any possible unhandled rollovers between the TimeBase and the first sample from individual channels), or a dummy zero-length *ChannelDataBlock for each channel if Session-level TimeCodes not allowed.  -->




  <element name="TimeBaseUTC" level="0" id="0x5462" type="uinteger" mandatory="0" multiple="1" minver="1">Session time base value in Unix Time. If present, used as the base for all future timecodes in the session.</element>
  


  <element name="SimpleChannelDataBlock" level="0" id="0xA0" type="binary" multiple="1" minver="1">This element contains potentially-channelized instrumentation data in a minimalist format. Its mandatory, fixed-length header includes a 2-byte modulo timecode (scaled to the channel's TimecodeScale, default of 1/32768 sec) and a 1-byte ChannelID.</element>

  <element name="ChannelDataBlock" level="0" id="0xA1" type="master" multiple="1" minver="1">This element contains child elements including instrumentation data associated to a channel. This is used for e.g. binding a timestamp(s) and/or metadata to a specific multi-sample block of sensor data, which may be written asynchronously with respect to other channels' data (i.e. multiplexed).</element>
  <element name="ChannelIDRef" level="1" id="0xB0" type="uinteger" multiple="0" minver="1">Child of ChannelDataBlock: the channel this data is associated with</element>
  <element name="ChannelFlags" level="1" id="0xB1" type="uinteger" multiple="0" minver="1">Child of ChannelDataBlock: optional flags to indicate datablock features such as discontinuity</element>
  <element name="ChannelDataPayload" level="1" id="0xB2" type="binary" multiple="0" minver="1">Child of ChannelDataBlock: the channel this data is associated with</element>
  <element name="StartTimeCodeAbs" level="1" id="0xB8" type="uinteger" mandatory="0" multiple="0" minver="1">Absolute time from the session TimeBase. If included at the Channel level, it is at the Channel scale.</element>
  <element name="EndTimeCodeAbs" level="1" id="0xB9" type="uinteger" mandatory="0" multiple="0" minver="1">Absolute time from the session TimeBase. If included at the Channel level, it is at the Channel scale.</element>
  <element name="StartTimeCodeAbsMod" level="1" id="0xBA" type="uinteger" mandatory="0" multiple="0" minver="1">Absolute time from session TimeBase mod (n_octets). Allows for a short, rolling-over (but still absolute) code.</element>
  <element name="EndTimeCodeAbsMod" level="1" id="0xBB" type="uinteger" mandatory="0" multiple="0" minver="1">Absolute time from session TimeBase mod (n_octets). Allows for a short, rolling-over (but still absolute) code.</element>






  
</table>
